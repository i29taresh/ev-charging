{"ast":null,"code":"/**\n * Lazily iterate over coordinates in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var point = { type: 'Point', coordinates: [0, 0] };\n * coordEach(point, function(coords) {\n *   // coords is equal to [0, 0]\n * });\n */\nfunction coordEach(layer, callback, excludeWrapCoord) {\n  var i,\n    j,\n    k,\n    g,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    isGeometryCollection,\n    isFeatureCollection = layer.type === 'FeatureCollection',\n    isFeature = layer.type === 'Feature',\n    stop = isFeatureCollection ? layer.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? layer.features[i].geometry : isFeature ? layer.geometry : layer;\n    isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      coords = geometry.coordinates;\n      wrapShrink = excludeWrapCoord && (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') ? 1 : 0;\n      if (geometry.type === 'Point') {\n        callback(coords);\n      } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {\n        for (j = 0; j < coords.length; j++) callback(coords[j]);\n      } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {\n        for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length - wrapShrink; k++) callback(coords[j][k]);\n      } else if (geometry.type === 'MultiPolygon') {\n        for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length; k++) for (l = 0; l < coords[j][k].length - wrapShrink; l++) callback(coords[j][k][l]);\n      } else {\n        throw new Error('Unknown Geometry Type');\n      }\n    }\n  }\n}\nmodule.exports.coordEach = coordEach;\n\n/**\n * Lazily reduce coordinates in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all coordinates is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, value) and returns\n * a new memo\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @param {*} memo the starting value of memo: can be any type.\n */\nfunction coordReduce(layer, callback, memo, excludeWrapCoord) {\n  coordEach(layer, function (coord) {\n    memo = callback(memo, coord);\n  }, excludeWrapCoord);\n  return memo;\n}\nmodule.exports.coordReduce = coordReduce;\n\n/**\n * Lazily iterate over property objects in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };\n * propEach(point, function(props) {\n *   // props is equal to { foo: 1}\n * });\n */\nfunction propEach(layer, callback) {\n  var i;\n  switch (layer.type) {\n    case 'FeatureCollection':\n      features = layer.features;\n      for (i = 0; i < layer.features.length; i++) {\n        callback(layer.features[i].properties);\n      }\n      break;\n    case 'Feature':\n      callback(layer.properties);\n      break;\n  }\n}\nmodule.exports.propEach = propEach;\n\n/**\n * Lazily reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, coord) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type.\n */\nfunction propReduce(layer, callback, memo) {\n  propEach(layer, function (prop) {\n    memo = callback(memo, prop);\n  });\n  return memo;\n}\nmodule.exports.propReduce = propReduce;","map":{"version":3,"names":["coordEach","layer","callback","excludeWrapCoord","i","j","k","g","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","isGeometryCollection","isFeatureCollection","type","isFeature","stop","features","length","geometries","coordinates","l","Error","module","exports","coordReduce","memo","coord","propEach","properties","propReduce","prop"],"sources":["/Users/bhavyatanwar/Desktop/ev-charging/node_modules/turf-meta/index.js"],"sourcesContent":["/**\n * Lazily iterate over coordinates in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var point = { type: 'Point', coordinates: [0, 0] };\n * coordEach(point, function(coords) {\n *   // coords is equal to [0, 0]\n * });\n */\nfunction coordEach(layer, callback, excludeWrapCoord) {\n  var i, j, k, g, geometry, stopG, coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    isGeometryCollection,\n    isFeatureCollection = layer.type === 'FeatureCollection',\n    isFeature = layer.type === 'Feature',\n    stop = isFeatureCollection ? layer.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n\n    geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :\n        (isFeature ? layer.geometry : layer));\n    isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n\n      geometry = isGeometryCollection ?\n          geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      coords = geometry.coordinates;\n\n      wrapShrink = (excludeWrapCoord &&\n        (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?\n        1 : 0;\n\n      if (geometry.type === 'Point') {\n        callback(coords);\n      } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {\n        for (j = 0; j < coords.length; j++) callback(coords[j]);\n      } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {\n        for (j = 0; j < coords.length; j++)\n          for (k = 0; k < coords[j].length - wrapShrink; k++)\n            callback(coords[j][k]);\n      } else if (geometry.type === 'MultiPolygon') {\n        for (j = 0; j < coords.length; j++)\n          for (k = 0; k < coords[j].length; k++)\n            for (l = 0; l < coords[j][k].length - wrapShrink; l++)\n              callback(coords[j][k][l]);\n      } else {\n        throw new Error('Unknown Geometry Type');\n      }\n    }\n  }\n}\nmodule.exports.coordEach = coordEach;\n\n/**\n * Lazily reduce coordinates in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all coordinates is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, value) and returns\n * a new memo\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @param {*} memo the starting value of memo: can be any type.\n */\nfunction coordReduce(layer, callback, memo, excludeWrapCoord) {\n  coordEach(layer, function(coord) {\n    memo = callback(memo, coord);\n  }, excludeWrapCoord);\n  return memo;\n}\nmodule.exports.coordReduce = coordReduce;\n\n/**\n * Lazily iterate over property objects in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };\n * propEach(point, function(props) {\n *   // props is equal to { foo: 1}\n * });\n */\nfunction propEach(layer, callback) {\n  var i;\n  switch (layer.type) {\n      case 'FeatureCollection':\n        features = layer.features;\n        for (i = 0; i < layer.features.length; i++) {\n            callback(layer.features[i].properties);\n        }\n        break;\n      case 'Feature':\n        callback(layer.properties);\n        break;\n  }\n}\nmodule.exports.propEach = propEach;\n\n/**\n * Lazily reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, coord) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type.\n */\nfunction propReduce(layer, callback, memo) {\n  propEach(layer, function(prop) {\n    memo = callback(memo, prop);\n  });\n  return memo;\n}\nmodule.exports.propReduce = propReduce;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAASA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,gBAAgB,EAAE;EACpD,IAAIC,CAAC;IAAEC,CAAC;IAAEC,CAAC;IAAEC,CAAC;IAAEC,QAAQ;IAAEC,KAAK;IAAEC,MAAM;IACrCC,uBAAuB;IACvBC,UAAU,GAAG,CAAC;IACdC,oBAAoB;IACpBC,mBAAmB,GAAGb,KAAK,CAACc,IAAI,KAAK,mBAAmB;IACxDC,SAAS,GAAGf,KAAK,CAACc,IAAI,KAAK,SAAS;IACpCE,IAAI,GAAGH,mBAAmB,GAAGb,KAAK,CAACiB,QAAQ,CAACC,MAAM,GAAG,CAAC;;EAExD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,KAAKf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,IAAI,EAAEb,CAAC,EAAE,EAAE;IAEzBO,uBAAuB,GAAIG,mBAAmB,GAAGb,KAAK,CAACiB,QAAQ,CAACd,CAAC,CAAC,CAACI,QAAQ,GACtEQ,SAAS,GAAGf,KAAK,CAACO,QAAQ,GAAGP,KAAO;IACzCY,oBAAoB,GAAGF,uBAAuB,CAACI,IAAI,KAAK,oBAAoB;IAC5EN,KAAK,GAAGI,oBAAoB,GAAGF,uBAAuB,CAACS,UAAU,CAACD,MAAM,GAAG,CAAC;IAE5E,KAAKZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,KAAK,EAAEF,CAAC,EAAE,EAAE;MAE1BC,QAAQ,GAAGK,oBAAoB,GAC3BF,uBAAuB,CAACS,UAAU,CAACb,CAAC,CAAC,GAAGI,uBAAuB;MACnED,MAAM,GAAGF,QAAQ,CAACa,WAAW;MAE7BT,UAAU,GAAIT,gBAAgB,KAC3BK,QAAQ,CAACO,IAAI,KAAK,SAAS,IAAIP,QAAQ,CAACO,IAAI,KAAK,cAAc,CAAC,GACjE,CAAC,GAAG,CAAC;MAEP,IAAIP,QAAQ,CAACO,IAAI,KAAK,OAAO,EAAE;QAC7Bb,QAAQ,CAACQ,MAAM,CAAC;MAClB,CAAC,MAAM,IAAIF,QAAQ,CAACO,IAAI,KAAK,YAAY,IAAIP,QAAQ,CAACO,IAAI,KAAK,YAAY,EAAE;QAC3E,KAAKV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,MAAM,CAACS,MAAM,EAAEd,CAAC,EAAE,EAAEH,QAAQ,CAACQ,MAAM,CAACL,CAAC,CAAC,CAAC;MACzD,CAAC,MAAM,IAAIG,QAAQ,CAACO,IAAI,KAAK,SAAS,IAAIP,QAAQ,CAACO,IAAI,KAAK,iBAAiB,EAAE;QAC7E,KAAKV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,MAAM,CAACS,MAAM,EAAEd,CAAC,EAAE,EAChC,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,MAAM,CAACL,CAAC,CAAC,CAACc,MAAM,GAAGP,UAAU,EAAEN,CAAC,EAAE,EAChDJ,QAAQ,CAACQ,MAAM,CAACL,CAAC,CAAC,CAACC,CAAC,CAAC,CAAC;MAC5B,CAAC,MAAM,IAAIE,QAAQ,CAACO,IAAI,KAAK,cAAc,EAAE;QAC3C,KAAKV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,MAAM,CAACS,MAAM,EAAEd,CAAC,EAAE,EAChC,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,MAAM,CAACL,CAAC,CAAC,CAACc,MAAM,EAAEb,CAAC,EAAE,EACnC,KAAKgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,MAAM,CAACL,CAAC,CAAC,CAACC,CAAC,CAAC,CAACa,MAAM,GAAGP,UAAU,EAAEU,CAAC,EAAE,EACnDpB,QAAQ,CAACQ,MAAM,CAACL,CAAC,CAAC,CAACC,CAAC,CAAC,CAACgB,CAAC,CAAC,CAAC;MACjC,CAAC,MAAM;QACL,MAAM,IAAIC,KAAK,CAAC,uBAAuB,CAAC;MAC1C;IACF;EACF;AACF;AACAC,MAAM,CAACC,OAAO,CAACzB,SAAS,GAAGA,SAAS;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0B,WAAWA,CAACzB,KAAK,EAAEC,QAAQ,EAAEyB,IAAI,EAAExB,gBAAgB,EAAE;EAC5DH,SAAS,CAACC,KAAK,EAAE,UAAS2B,KAAK,EAAE;IAC/BD,IAAI,GAAGzB,QAAQ,CAACyB,IAAI,EAAEC,KAAK,CAAC;EAC9B,CAAC,EAAEzB,gBAAgB,CAAC;EACpB,OAAOwB,IAAI;AACb;AACAH,MAAM,CAACC,OAAO,CAACC,WAAW,GAAGA,WAAW;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,QAAQA,CAAC5B,KAAK,EAAEC,QAAQ,EAAE;EACjC,IAAIE,CAAC;EACL,QAAQH,KAAK,CAACc,IAAI;IACd,KAAK,mBAAmB;MACtBG,QAAQ,GAAGjB,KAAK,CAACiB,QAAQ;MACzB,KAAKd,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACiB,QAAQ,CAACC,MAAM,EAAEf,CAAC,EAAE,EAAE;QACxCF,QAAQ,CAACD,KAAK,CAACiB,QAAQ,CAACd,CAAC,CAAC,CAAC0B,UAAU,CAAC;MAC1C;MACA;IACF,KAAK,SAAS;MACZ5B,QAAQ,CAACD,KAAK,CAAC6B,UAAU,CAAC;MAC1B;EACN;AACF;AACAN,MAAM,CAACC,OAAO,CAACI,QAAQ,GAAGA,QAAQ;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,UAAUA,CAAC9B,KAAK,EAAEC,QAAQ,EAAEyB,IAAI,EAAE;EACzCE,QAAQ,CAAC5B,KAAK,EAAE,UAAS+B,IAAI,EAAE;IAC7BL,IAAI,GAAGzB,QAAQ,CAACyB,IAAI,EAAEK,IAAI,CAAC;EAC7B,CAAC,CAAC;EACF,OAAOL,IAAI;AACb;AACAH,MAAM,CAACC,OAAO,CAACM,UAAU,GAAGA,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}