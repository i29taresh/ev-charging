{"ast":null,"code":"import * as types from '../constants/action_types';\nimport utils from '../utils';\nconst request = new XMLHttpRequest();\nfunction originPoint(coordinates) {\n  return dispatch => {\n    const origin = utils.createPoint(coordinates, {\n      id: 'origin',\n      'marker-symbol': 'A'\n    });\n    dispatch({\n      type: types.ORIGIN,\n      origin\n    });\n    dispatch(eventEmit('origin', {\n      feature: origin\n    }));\n  };\n}\nfunction destinationPoint(coordinates) {\n  return dispatch => {\n    const destination = utils.createPoint(coordinates, {\n      id: 'destination',\n      'marker-symbol': 'B'\n    });\n    dispatch({\n      type: types.DESTINATION,\n      destination\n    });\n    dispatch(eventEmit('destination', {\n      feature: destination\n    }));\n  };\n}\nfunction setDirections(directions) {\n  return dispatch => {\n    dispatch({\n      type: types.DIRECTIONS,\n      directions\n    });\n    dispatch(eventEmit('route', {\n      route: directions\n    }));\n  };\n}\nfunction updateWaypoints(waypoints) {\n  return {\n    type: types.WAYPOINTS,\n    waypoints: waypoints\n  };\n}\nfunction setHoverMarker(feature) {\n  return {\n    type: types.HOVER_MARKER,\n    hoverMarker: feature\n  };\n}\nfunction fetchDirections() {\n  return (dispatch, getState) => {\n    const {\n      api,\n      accessToken,\n      routeIndex,\n      profile,\n      alternatives,\n      congestion,\n      destination,\n      language,\n      exclude\n    } = getState();\n    // if there is no destination set, do not make request because it will fail\n    if (!(destination && destination.geometry)) return;\n    const query = buildDirectionsQuery(getState);\n\n    // Request params\n    var options = [];\n    options.push('geometries=polyline');\n    if (alternatives) options.push('alternatives=true');\n    if (congestion) options.push('annotations=congestion');\n    options.push('steps=true');\n    options.push('overview=full');\n    if (language) options.push('language=' + language);\n    if (exclude) options.push('exclude=' + exclude);\n    if (accessToken) options.push('access_token=' + accessToken);\n    request.abort();\n    request.open('GET', `${api}${profile}/${query}.json?${options.join('&')}`, true);\n    request.onload = () => {\n      if (request.status >= 200 && request.status < 400) {\n        var data = JSON.parse(request.responseText);\n        if (data.error) {\n          dispatch(setDirections([]));\n          return dispatch(setError(data.error));\n        }\n        dispatch(setError(null));\n        if (!data.routes[routeIndex]) dispatch(setRouteIndex(0));\n        dispatch(setDirections(data.routes));\n\n        // Revise origin / destination points\n        dispatch(originPoint(data.waypoints[0].location));\n        dispatch(destinationPoint(data.waypoints[data.waypoints.length - 1].location));\n      } else {\n        dispatch(setDirections([]));\n        return dispatch(setError(JSON.parse(request.responseText).message));\n      }\n    };\n    request.onerror = () => {\n      dispatch(setDirections([]));\n      return dispatch(setError(JSON.parse(request.responseText).message));\n    };\n    request.send();\n  };\n}\n\n/*\n * Build query used to fetch directions\n *\n * @param {Function} state\n */\nfunction buildDirectionsQuery(state) {\n  const {\n    origin,\n    destination,\n    waypoints\n  } = state();\n  let query = [];\n  query.push(origin.geometry.coordinates.join(','));\n  query.push(';');\n\n  // Add any waypoints.\n  if (waypoints.length) {\n    waypoints.forEach(waypoint => {\n      query.push(waypoint.geometry.coordinates.join(','));\n      query.push(';');\n    });\n  }\n  query.push(destination.geometry.coordinates.join(','));\n  return encodeURIComponent(query.join(''));\n}\nfunction normalizeWaypoint(waypoint) {\n  const properties = {\n    id: 'waypoint'\n  };\n  return Object.assign(waypoint, {\n    properties: waypoint.properties ? Object.assign(waypoint.properties, properties) : properties\n  });\n}\nfunction setError(error) {\n  return dispatch => {\n    dispatch({\n      type: 'ERROR',\n      error\n    });\n    if (error) dispatch(eventEmit('error', {\n      error: error\n    }));\n  };\n}\nexport function queryOrigin(query) {\n  return {\n    type: types.ORIGIN_QUERY,\n    query\n  };\n}\nexport function queryDestination(query) {\n  return {\n    type: types.DESTINATION_QUERY,\n    query\n  };\n}\nexport function queryOriginCoordinates(coords) {\n  return {\n    type: types.ORIGIN_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\nexport function queryDestinationCoordinates(coords) {\n  return {\n    type: types.DESTINATION_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\nexport function clearOrigin() {\n  return dispatch => {\n    dispatch({\n      type: types.ORIGIN_CLEAR\n    });\n    dispatch(eventEmit('clear', {\n      type: 'origin'\n    }));\n    dispatch(setError(null));\n  };\n}\nexport function clearDestination() {\n  return dispatch => {\n    dispatch({\n      type: types.DESTINATION_CLEAR\n    });\n    dispatch(eventEmit('clear', {\n      type: 'destination'\n    }));\n    dispatch(setError(null));\n  };\n}\nexport function setOptions(options) {\n  return {\n    type: types.SET_OPTIONS,\n    options: options\n  };\n}\nexport function hoverMarker(coordinates) {\n  return dispatch => {\n    const feature = coordinates ? utils.createPoint(coordinates, {\n      id: 'hover'\n    }) : {};\n    dispatch(setHoverMarker(feature));\n  };\n}\nexport function setRouteIndex(routeIndex) {\n  return {\n    type: types.ROUTE_INDEX,\n    routeIndex\n  };\n}\nexport function createOrigin(coordinates) {\n  return (dispatch, getState) => {\n    const {\n      destination\n    } = getState();\n    dispatch(originPoint(coordinates));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function createDestination(coordinates) {\n  return (dispatch, getState) => {\n    const {\n      origin\n    } = getState();\n    dispatch(destinationPoint(coordinates));\n    if (origin.geometry) dispatch(fetchDirections());\n  };\n}\nexport function setProfile(profile) {\n  return (dispatch, getState) => {\n    const {\n      origin,\n      destination\n    } = getState();\n    dispatch({\n      type: types.DIRECTIONS_PROFILE,\n      profile\n    });\n    dispatch(eventEmit('profile', {\n      profile\n    }));\n    if (origin.geometry && destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function reverse() {\n  return (dispatch, getState) => {\n    const state = getState();\n    if (state.destination.geometry) dispatch(originPoint(state.destination.geometry.coordinates));\n    if (state.origin.geometry) dispatch(destinationPoint(state.origin.geometry.coordinates));\n    if (state.origin.geometry && state.destination.geometry) dispatch(fetchDirections());\n  };\n}\n\n/*\n * Set origin from coordinates\n *\n * @param {Array<number>} coordinates [lng, lat] array.\n */\nexport function setOriginFromCoordinates(coords) {\n  return dispatch => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(queryOriginCoordinates(coords));\n    dispatch(createOrigin(coords));\n  };\n}\n\n/*\n * Set destination from coordinates\n *\n * @param {Array<number>} coords [lng, lat] array.\n */\nexport function setDestinationFromCoordinates(coords) {\n  return dispatch => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(createDestination(coords));\n    dispatch(queryDestinationCoordinates(coords));\n  };\n}\nexport function addWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let {\n      destination,\n      waypoints\n    } = getState();\n    waypoints.splice(index, 0, normalizeWaypoint(waypoint));\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function setWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let {\n      destination,\n      waypoints\n    } = getState();\n    waypoints[index] = normalizeWaypoint(waypoint);\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function removeWaypoint(waypoint) {\n  return (dispatch, getState) => {\n    let {\n      destination,\n      waypoints\n    } = getState();\n    waypoints = waypoints.filter(way => {\n      return !utils.coordinateMatch(way, waypoint);\n    });\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function eventSubscribe(type, fn) {\n  return (dispatch, getState) => {\n    const {\n      events\n    } = getState();\n    events[type] = events[type] || [];\n    events[type].push(fn);\n    return {\n      type: types.EVENTS,\n      events\n    };\n  };\n}\nexport function eventEmit(type, data) {\n  return (dispatch, getState) => {\n    const {\n      events\n    } = getState();\n    if (!events[type]) {\n      return {\n        type: types.EVENTS,\n        events\n      };\n    }\n    const listeners = events[type].slice();\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i].call(this, data);\n    }\n  };\n}","map":{"version":3,"names":["types","utils","request","XMLHttpRequest","originPoint","coordinates","dispatch","origin","createPoint","id","type","ORIGIN","eventEmit","feature","destinationPoint","destination","DESTINATION","setDirections","directions","DIRECTIONS","route","updateWaypoints","waypoints","WAYPOINTS","setHoverMarker","HOVER_MARKER","hoverMarker","fetchDirections","getState","api","accessToken","routeIndex","profile","alternatives","congestion","language","exclude","geometry","query","buildDirectionsQuery","options","push","abort","open","join","onload","status","data","JSON","parse","responseText","error","setError","routes","setRouteIndex","location","length","message","onerror","send","state","forEach","waypoint","encodeURIComponent","normalizeWaypoint","properties","Object","assign","queryOrigin","ORIGIN_QUERY","queryDestination","DESTINATION_QUERY","queryOriginCoordinates","coords","ORIGIN_FROM_COORDINATES","queryDestinationCoordinates","DESTINATION_FROM_COORDINATES","clearOrigin","ORIGIN_CLEAR","clearDestination","DESTINATION_CLEAR","setOptions","SET_OPTIONS","ROUTE_INDEX","createOrigin","createDestination","setProfile","DIRECTIONS_PROFILE","reverse","setOriginFromCoordinates","validCoords","wrap","isNaN","Error","setDestinationFromCoordinates","addWaypoint","index","splice","setWaypoint","removeWaypoint","filter","way","coordinateMatch","eventSubscribe","fn","events","EVENTS","listeners","slice","i","call"],"sources":["/Users/bhavyatanwar/Desktop/ev-charging/node_modules/mapbox-gl-direction-location/src/actions/index.js"],"sourcesContent":["import * as types from '../constants/action_types';\nimport utils from '../utils';\nconst request = new XMLHttpRequest();\n\nfunction originPoint(coordinates) {\n  return (dispatch) => {\n    const origin = utils.createPoint(coordinates, {\n      id: 'origin',\n      'marker-symbol': 'A'\n    });\n\n    dispatch({ type: types.ORIGIN, origin });\n    dispatch(eventEmit('origin', { feature: origin }));\n  };\n}\n\nfunction destinationPoint(coordinates) {\n  return (dispatch) => {\n    const destination = utils.createPoint(coordinates, {\n      id: 'destination',\n      'marker-symbol': 'B'\n    });\n\n    dispatch({ type: types.DESTINATION, destination });\n    dispatch(eventEmit('destination', { feature: destination }));\n  };\n}\n\nfunction setDirections(directions) {\n  return dispatch => {\n    dispatch({\n      type: types.DIRECTIONS,\n      directions\n    });\n    dispatch(eventEmit('route', { route: directions }));\n  };\n}\n\nfunction updateWaypoints(waypoints) {\n  return {\n    type: types.WAYPOINTS,\n    waypoints: waypoints\n  };\n}\n\nfunction setHoverMarker(feature) {\n  return {\n    type: types.HOVER_MARKER,\n    hoverMarker: feature\n  };\n}\n\nfunction fetchDirections() {\n  return (dispatch, getState) => {\n    const { api, accessToken, routeIndex, profile, alternatives, congestion, destination, language, exclude } = getState();\n    // if there is no destination set, do not make request because it will fail\n    if (!(destination && destination.geometry)) return;\n\n    const query = buildDirectionsQuery(getState);\n\n    // Request params\n    var options = [];\n    options.push('geometries=polyline');\n    if (alternatives) options.push('alternatives=true');\n    if (congestion) options.push('annotations=congestion');\n    options.push('steps=true');\n    options.push('overview=full');\n    if (language) options.push('language='+language);\n    if (exclude) options.push('exclude=' + exclude);\n    if (accessToken) options.push('access_token=' + accessToken);\n    request.abort();\n    request.open('GET', `${api}${profile}/${query}.json?${options.join('&')}`, true);\n\n    request.onload = () => {\n      if (request.status >= 200 && request.status < 400) {\n        var data = JSON.parse(request.responseText);\n        if (data.error) {\n          dispatch(setDirections([]));\n          return dispatch(setError(data.error));\n        }\n\n        dispatch(setError(null));\n        if (!data.routes[routeIndex]) dispatch(setRouteIndex(0));\n        dispatch(setDirections(data.routes));\n\n        // Revise origin / destination points\n        dispatch(originPoint(data.waypoints[0].location));\n        dispatch(destinationPoint(data.waypoints[data.waypoints.length - 1].location));\n      } else {\n        dispatch(setDirections([]));\n        return dispatch(setError(JSON.parse(request.responseText).message));\n      }\n    };\n\n    request.onerror = () => {\n      dispatch(setDirections([]));\n      return dispatch(setError(JSON.parse(request.responseText).message));\n    };\n\n    request.send();\n  };\n}\n\n/*\n * Build query used to fetch directions\n *\n * @param {Function} state\n */\nfunction buildDirectionsQuery(state) {\n  const { origin, destination, waypoints } = state();\n\n  let query = [];\n  query.push((origin.geometry.coordinates).join(','));\n  query.push(';');\n\n  // Add any waypoints.\n  if (waypoints.length) {\n    waypoints.forEach((waypoint) => {\n      query.push((waypoint.geometry.coordinates).join(','));\n      query.push(';');\n    });\n  }\n\n  query.push((destination.geometry.coordinates).join(','));\n  return encodeURIComponent(query.join(''));\n}\n\nfunction normalizeWaypoint(waypoint) {\n  const properties = { id: 'waypoint' };\n  return Object.assign(waypoint, {\n    properties: waypoint.properties ?\n      Object.assign(waypoint.properties, properties) :\n      properties\n  });\n}\n\nfunction setError(error) {\n  return dispatch => {\n    dispatch({\n      type: 'ERROR',\n      error\n    });\n    if (error) dispatch(eventEmit('error', { error: error }));\n  };\n}\n\nexport function queryOrigin(query) {\n  return {\n    type: types.ORIGIN_QUERY,\n    query\n  };\n}\n\nexport function queryDestination(query) {\n  return {\n    type: types.DESTINATION_QUERY,\n    query\n  };\n}\n\nexport function queryOriginCoordinates(coords) {\n  return {\n    type: types.ORIGIN_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\n\nexport function queryDestinationCoordinates(coords) {\n  return {\n    type: types.DESTINATION_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\n\nexport function clearOrigin() {\n  return dispatch => {\n    dispatch({\n      type: types.ORIGIN_CLEAR\n    });\n    dispatch(eventEmit('clear', { type: 'origin' }));\n    dispatch(setError(null));\n  };\n}\n\nexport function clearDestination() {\n  return dispatch => {\n    dispatch({\n      type: types.DESTINATION_CLEAR\n    });\n    dispatch(eventEmit('clear', { type: 'destination' }));\n    dispatch(setError(null));\n  };\n}\n\nexport function setOptions(options) {\n  return {\n    type: types.SET_OPTIONS,\n    options: options\n  };\n}\n\nexport function hoverMarker(coordinates) {\n  return (dispatch) => {\n    const feature = (coordinates) ? utils.createPoint(coordinates, { id: 'hover'}) : {};\n    dispatch(setHoverMarker(feature));\n  };\n}\n\nexport function setRouteIndex(routeIndex) {\n  return {\n    type: types.ROUTE_INDEX,\n    routeIndex\n  };\n}\n\nexport function createOrigin(coordinates) {\n  return (dispatch, getState) => {\n    const { destination } = getState();\n    dispatch(originPoint(coordinates));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function createDestination(coordinates) {\n  return (dispatch, getState) => {\n    const { origin } = getState();\n    dispatch(destinationPoint(coordinates));\n    if (origin.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function setProfile(profile) {\n  return (dispatch, getState) => {\n    const { origin, destination } = getState();\n    dispatch({ type: types.DIRECTIONS_PROFILE, profile });\n    dispatch(eventEmit('profile', { profile }));\n    if (origin.geometry && destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function reverse() {\n  return (dispatch, getState) => {\n    const state = getState();\n    if (state.destination.geometry) dispatch(originPoint(state.destination.geometry.coordinates));\n    if (state.origin.geometry) dispatch(destinationPoint(state.origin.geometry.coordinates));\n    if (state.origin.geometry && state.destination.geometry) dispatch(fetchDirections());\n  };\n}\n\n/*\n * Set origin from coordinates\n *\n * @param {Array<number>} coordinates [lng, lat] array.\n */\nexport function setOriginFromCoordinates(coords) {\n  return (dispatch) => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(queryOriginCoordinates(coords));\n    dispatch(createOrigin(coords));\n  };\n}\n\n/*\n * Set destination from coordinates\n *\n * @param {Array<number>} coords [lng, lat] array.\n */\nexport function setDestinationFromCoordinates(coords) {\n  return (dispatch) => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(createDestination(coords));\n    dispatch(queryDestinationCoordinates(coords));\n  };\n}\n\nexport function addWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let { destination, waypoints } = getState();\n    waypoints.splice(index, 0, normalizeWaypoint(waypoint));\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function setWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let { destination, waypoints } = getState();\n    waypoints[index] = normalizeWaypoint(waypoint);\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function removeWaypoint(waypoint) {\n  return (dispatch, getState) => {\n    let { destination, waypoints } = getState();\n      waypoints = waypoints.filter((way) => {\n        return !utils.coordinateMatch(way, waypoint);\n      });\n\n      dispatch(updateWaypoints(waypoints));\n      if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function eventSubscribe(type, fn) {\n  return (dispatch, getState) => {\n    const { events } = getState();\n    events[type] = events[type] || [];\n    events[type].push(fn);\n    return {\n      type: types.EVENTS,\n      events\n    };\n  };\n}\n\nexport function eventEmit(type, data) {\n  return (dispatch, getState) => {\n    const { events } = getState();\n\n    if (!events[type]) {\n      return {\n        type: types.EVENTS,\n        events\n      };\n    }\n\n    const listeners = events[type].slice();\n\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i].call(this, data);\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}